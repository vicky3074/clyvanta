name: üöÄ Robust Docker Hub Deployment

on:
  push:
    branches: [ main, staging ]

jobs:
  build-and-deploy:
    runs-on: ubuntu-latest
    environment: production
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
    
    - name: Login to Docker Hub
      uses: docker/login-action@v3
      with:
        username: ${{ secrets.DOCKER_USERNAME }}
        password: ${{ secrets.DOCKER_PASSWORD }}
    
    - name: Build and Push Complete Docker Image
      run: |
        echo "üî® Building complete self-contained Docker image for branch: ${{ github.ref_name }}"
        docker build -f Dockerfile.complete -t vicky3074/clyvanta-complete:${{ github.ref_name }} .
        echo "üì§ Pushing complete image to Docker Hub..."
        docker push vicky3074/clyvanta-complete:${{ github.ref_name }}
        echo "‚úÖ Successfully pushed vicky3074/clyvanta-complete:${{ github.ref_name }}"
        
        # Also tag as latest for main branch
        if [ "${{ github.ref_name }}" = "main" ]; then
          docker tag vicky3074/clyvanta-complete:${{ github.ref_name }} vicky3074/clyvanta-complete:latest
          docker push vicky3074/clyvanta-complete:latest
          echo "‚úÖ Also pushed as vicky3074/clyvanta-complete:latest"
        fi
        
    - name: Deploy to Production
      if: github.ref == 'refs/heads/main'
      run: |
        echo "üöÄ Starting robust deployment to production..."
        
        # Setup SSH
        mkdir -p ~/.ssh
        echo "${{ secrets.SSH_PRIVATE_KEY }}" > ~/.ssh/deploy_key
        chmod 600 ~/.ssh/deploy_key
        ssh-keyscan -H ${{ secrets.DROPLET_IP }} >> ~/.ssh/known_hosts
        
        # Self-contained deployment - no filesystem dependencies
        ssh -i ~/.ssh/deploy_key -o StrictHostKeyChecking=no ubuntu@${{ secrets.DROPLET_IP }} << 'EOF'
          echo "üì¶ Starting self-contained Docker Hub deployment..."
          cd clyvanta-new || { echo "‚ùå Project directory not found"; exit 1; }
          
          echo "üìÑ Ensuring complete docker-compose file is available..."
          git pull origin main || echo "‚ö†Ô∏è Git pull failed, using existing files"
          
          echo "üìã Current system status:"
          docker ps --format "table {{.Names}}\t{{.Status}}\t{{.Ports}}"
          
          echo "‚¨áÔ∏è Pulling complete self-contained image..."
          docker pull vicky3074/clyvanta-complete:latest || { echo "‚ùå Failed to pull complete Docker image"; exit 1; }
          
          echo "üõë Gracefully stopping all containers..."
          docker compose -f docker-compose.complete.yml down --timeout 30 || echo "‚ö†Ô∏è Some containers may already be stopped"
          
          echo "üßπ Cleaning up old containers and networks..."
          docker container prune -f
          docker network prune -f
          
          echo "üßπ Ensuring domain ports are available..."
          sudo fuser -k 80/tcp 443/tcp 8080/tcp 2>/dev/null || true
          sleep 5
          
          echo "üöÄ Starting self-contained deployment..."
          docker compose -f docker-compose.complete.yml up -d --force-recreate
          
          echo "‚è≥ Waiting for containers to initialize (60s)..."
          sleep 60
          
          echo "üîç Comprehensive container diagnostics..."
          echo "üìã All containers:"
          docker ps -a --format "table {{.Names}}\t{{.Status}}\t{{.Ports}}\t{{.Image}}"
          
          echo "üìã Running containers only:"
          docker ps --format "table {{.Names}}\t{{.Status}}\t{{.Ports}}"
          
          echo "üìã Docker networks:"
          docker network ls
          
          echo "üìã Compose project containers:"
          docker compose ps
          
          # Find the complete container
          COMPLETE_CONTAINER=$(docker ps --filter "label=com.docker.compose.service=clyvanta-complete" --format "{{.Names}}" | head -1)
          
          echo "üîç Detected containers:"
          echo "  Complete container: ${COMPLETE_CONTAINER:-NOT_FOUND}"
          
          # Verify complete container is responding (using dynamic name)
          echo "üåê Testing complete container health..."
          if [ -n "$COMPLETE_CONTAINER" ]; then
            for i in {1..10}; do
              echo "Attempt $i: Testing container $COMPLETE_CONTAINER..."
              if docker exec "$COMPLETE_CONTAINER" curl -f -s --max-time 5 http://localhost:80 > /dev/null 2>&1; then
                echo "‚úÖ Complete container health check passed on attempt $i"
                CONTAINER_HEALTHY=true
                break
              else
                echo "‚è≥ Complete container health check attempt $i/10 failed, retrying..."
                sleep 6
              fi
              
              if [ $i -eq 10 ]; then
                echo "‚ùå Complete container health checks failed after 10 attempts"
                echo "üìã Container logs:"
                docker logs "$COMPLETE_CONTAINER" --tail 50
                echo "üìã Container inspect:"
                docker inspect "$COMPLETE_CONTAINER" --format '{{.State.Status}}: {{.State.Error}}'
              fi
            done
          else
            echo "‚ùå No complete container found - checking external access..."
            CONTAINER_HEALTHY=false
          fi
          
          # Alternative health check strategy - external access (more reliable)
          echo "üîó Testing external service access..."
          EXTERNAL_HEALTHY=false
          
          for i in {1..12}; do
            echo "External attempt $i: Testing service endpoints..."
            
            # Test port 80 (main nginx) - CRITICAL for domain mapping
            if curl -f -s --max-time 10 http://localhost:80 > /dev/null 2>&1; then
              echo "‚úÖ Port 80 accessible on attempt $i (DOMAIN MAPPING READY)"
              EXTERNAL_HEALTHY=true
              break
            fi
            
            # Test port 443 (SSL) - Required for HTTPS domain
            if curl -f -s -k --max-time 10 https://localhost:443 > /dev/null 2>&1; then
              echo "‚úÖ Port 443 SSL accessible on attempt $i (HTTPS DOMAIN READY)"
              EXTERNAL_HEALTHY=true
              break
            fi
            
            # Test port 8080 (backup nginx)  
            if curl -f -s --max-time 10 http://localhost:8080 > /dev/null 2>&1; then
              echo "‚úÖ Port 8080 accessible on attempt $i (BACKUP ACCESS)"
              EXTERNAL_HEALTHY=true
              break
            fi
            
            # Test if complete container is directly accessible (troubleshooting)
            if [ -n "$COMPLETE_CONTAINER" ]; then
              CONTAINER_IP=$(docker inspect "$COMPLETE_CONTAINER" --format '{{range .NetworkSettings.Networks}}{{.IPAddress}}{{end}}' | head -1)
              if [ -n "$CONTAINER_IP" ] && curl -f -s --max-time 5 "http://${CONTAINER_IP}:80" > /dev/null 2>&1; then
                echo "‚úÖ Complete container directly accessible at $CONTAINER_IP:80 on attempt $i"
                EXTERNAL_HEALTHY=true
                break
              fi
            fi
            
            echo "‚è≥ External access attempt $i/12 failed, retrying..."
            sleep 8
          done
          
          # Final health assessment
          if [ "$CONTAINER_HEALTHY" = "true" ] || [ "$EXTERNAL_HEALTHY" = "true" ]; then
            echo "‚úÖ Self-contained service is healthy (complete container working)"
          else
            echo "‚ùå Self-contained service health checks failed completely"
            echo "üìã Final diagnostics:"
            docker ps -a
            if [ -n "$COMPLETE_CONTAINER" ]; then
              echo "üìã Complete container logs:"
              docker logs "$COMPLETE_CONTAINER" --tail 50
            fi
            echo "üìã System resources:"
            df -h
            free -h
            exit 1
          fi
          
          echo "üèÅ Deployment completed successfully!"
          echo "üìä Final container status:"
          docker ps --format "table {{.Names}}\t{{.Status}}\t{{.Ports}}"
        EOF
        
        # Cleanup SSH key
        rm -f ~/.ssh/deploy_key
        echo "‚úÖ SSH deployment completed"
        
    - name: Comprehensive Production Verification
      if: github.ref == 'refs/heads/main'
      run: |
        echo "üåç Comprehensive production deployment verification..."
        sleep 45
        
        # Domain-focused verification strategy
        echo "üì° Testing domain mapping endpoints with progressive timeouts..."
        DIRECT_ACCESS=false
        
        # Test domain-critical ports first
        for timeout in 10 20 30; do
          echo "Testing with ${timeout}s timeout..."
          
          # Port 80 is CRITICAL for domain mapping (Cloudflare ‚Üí 80)
          echo "  Testing port 80 (DOMAIN CRITICAL)..."
          if curl -f -s --max-time $timeout "http://${{ secrets.DROPLET_IP }}:80" > /dev/null 2>&1; then
            echo "‚úÖ Port 80 accessible - DOMAIN MAPPING WORKING (${timeout}s)"
            DIRECT_ACCESS=true
            WORKING_PORT=80
            DOMAIN_READY=true
            break
          fi
          
          # Port 443 for HTTPS domain
          echo "  Testing port 443 (HTTPS DOMAIN)..."
          if curl -f -s -k --max-time $timeout "https://${{ secrets.DROPLET_IP }}:443" > /dev/null 2>&1; then
            echo "‚úÖ Port 443 SSL accessible - HTTPS DOMAIN WORKING (${timeout}s)"
            DIRECT_ACCESS=true
            WORKING_PORT=443
            DOMAIN_READY=true
            break
          fi
          
          # Port 8080 as fallback
          echo "  Testing port 8080 (FALLBACK)..."
          if curl -f -s --max-time $timeout "http://${{ secrets.DROPLET_IP }}:8080" > /dev/null 2>&1; then
            echo "‚úÖ Port 8080 accessible - BACKUP ACCESS (${timeout}s)"
            DIRECT_ACCESS=true
            WORKING_PORT=8080
            DOMAIN_READY=false
            break
          fi
          
          sleep 5
        done
        
        # Content verification if server responds
        if [ "$DIRECT_ACCESS" = "true" ]; then
          echo "üìÑ Verifying content integrity..."
          CONTENT=$(curl -s --max-time 15 "http://${{ secrets.DROPLET_IP }}:$WORKING_PORT" | head -500)
          if echo "$CONTENT" | grep -q "Great Ideas Deserve Great Technology"; then
            echo "‚úÖ Content verification passed - latest code deployed"
            CONTENT_OK=true
          else
            echo "‚ö†Ô∏è Content verification failed - may be old deployment"
            echo "First 200 chars of response:"
            echo "$CONTENT" | head -c 200
            CONTENT_OK=false
          fi
        fi
        
        # Domain verification with enhanced error reporting
        echo "üåê Testing domain access via Cloudflare..."
        DOMAIN_ACCESS=false
        
        for i in {1..6}; do
          echo "Domain attempt $i/6..."
          RESPONSE=$(curl -s -w "HTTP_%{http_code}_TIME_%{time_total}s" --max-time 25 https://clyvanta.com -o /tmp/domain_response.html 2>&1)
          HTTP_CODE=$(echo "$RESPONSE" | grep -o 'HTTP_[0-9]*' | sed 's/HTTP_//')
          
          if [ "$HTTP_CODE" = "200" ]; then
            echo "‚úÖ Domain accessible (HTTP $HTTP_CODE) on attempt $i"
            
            # Verify domain content
            if grep -q "Great Ideas Deserve Great Technology" /tmp/domain_response.html 2>/dev/null; then
              echo "‚úÖ Domain content verification passed"
              DOMAIN_ACCESS=true
              break
            else
              echo "‚ö†Ô∏è Domain responds but content may be cached"
            fi
          elif [ "$HTTP_CODE" = "521" ]; then
            echo "‚ö†Ô∏è Cloudflare 521 error (Web server is down) on attempt $i"
          elif [ "$HTTP_CODE" = "522" ]; then
            echo "‚ö†Ô∏è Cloudflare 522 error (Connection timed out) on attempt $i"
          else
            echo "‚ö†Ô∏è Domain returned HTTP $HTTP_CODE on attempt $i"
          fi
          
          sleep 12
        done
        
        # Final assessment with domain mapping focus
        echo "üìä Deployment Assessment:"
        echo "  Direct Server Access: ${DIRECT_ACCESS}"
        echo "  Content Verification: ${CONTENT_OK:-N/A}"
        echo "  Domain Mapping Ready: ${DOMAIN_READY:-false}"
        echo "  Domain Access: ${DOMAIN_ACCESS}"
        echo "  Working Port: ${WORKING_PORT:-None}"
        
        # Domain-focused success criteria
        if [ "$DIRECT_ACCESS" = "true" ] && [ "$CONTENT_OK" = "true" ] && [ "$DOMAIN_READY" = "true" ]; then
          echo "‚úÖ COMPLETE SUCCESS: Domain mapping working + latest content deployed"
          echo "üåç Port 80/443 accessible - clyvanta.com should work immediately"
          if [ "$DOMAIN_ACCESS" = "true" ]; then
            echo "‚úÖ VERIFIED: Domain also tested and working"
          else
            echo "‚ÑπÔ∏è Domain may take 1-2 minutes to propagate through Cloudflare"
          fi
          exit 0
        elif [ "$DIRECT_ACCESS" = "true" ] && [ "$CONTENT_OK" = "true" ]; then
          echo "‚ö†Ô∏è PARTIAL SUCCESS: Content deployed but domain mapping issues"
          echo "üîç Server accessible on port ${WORKING_PORT} but not domain-critical ports 80/443"
          echo "‚ÑπÔ∏è Production recovered but may need domain mapping investigation"
          exit 0
        elif [ "$DIRECT_ACCESS" = "true" ]; then
          echo "‚ö†Ô∏è MINIMAL SUCCESS: Server accessible but content/domain issues"
          echo "üîç Working port: ${WORKING_PORT}"
          echo "‚ÑπÔ∏è Production may be accessible but not latest deployment"
          exit 0
        else
          echo "‚ùå DEPLOYMENT FAILED: Server completely inaccessible"
          echo "üîç Troubleshooting info:"
          echo "  - Both container health AND domain mapping failed"
          echo "  - Server IP: ${{ secrets.DROPLET_IP }}"
          echo "  - Tested ports: 80 (domain), 443 (SSL), 8080 (backup)"
          echo "  - Check SSL certificate generation and port conflicts"
          exit 1
        fi