name: üöÄ Robust Docker Hub Deployment

on:
  push:
    branches: [ main, staging ]

jobs:
  build-and-deploy:
    runs-on: ubuntu-latest
    environment: production
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
    
    - name: Login to Docker Hub
      uses: docker/login-action@v3
      with:
        username: ${{ secrets.DOCKER_USERNAME }}
        password: ${{ secrets.DOCKER_PASSWORD }}
    
    - name: Build and Push Docker Image
      run: |
        echo "üî® Building Docker image for branch: ${{ github.ref_name }}"
        docker build -t vicky3074/clyvanta:${{ github.ref_name }} .
        echo "üì§ Pushing to Docker Hub..."
        docker push vicky3074/clyvanta:${{ github.ref_name }}
        echo "‚úÖ Successfully pushed vicky3074/clyvanta:${{ github.ref_name }}"
        
    - name: Deploy to Production
      if: github.ref == 'refs/heads/main'
      run: |
        echo "üöÄ Starting robust deployment to production..."
        
        # Setup SSH
        mkdir -p ~/.ssh
        echo "${{ secrets.SSH_PRIVATE_KEY }}" > ~/.ssh/deploy_key
        chmod 600 ~/.ssh/deploy_key
        ssh-keyscan -H ${{ secrets.DROPLET_IP }} >> ~/.ssh/known_hosts
        
        # Robust deployment with proper container handling
        ssh -i ~/.ssh/deploy_key -o StrictHostKeyChecking=no ubuntu@${{ secrets.DROPLET_IP }} << 'EOF'
          echo "üì¶ Starting Docker Hub deployment..."
          cd clyvanta-new || { echo "‚ùå Project directory not found"; exit 1; }
          
          echo "üìã Current system status:"
          docker ps --format "table {{.Names}}\t{{.Status}}\t{{.Ports}}"
          
          echo "‚¨áÔ∏è Pulling latest Docker Hub image..."
          docker pull vicky3074/clyvanta:latest || { echo "‚ùå Failed to pull Docker image"; exit 1; }
          
          echo "üõë Gracefully stopping all containers..."
          docker compose down --timeout 30 || echo "‚ö†Ô∏è Some containers may already be stopped"
          
          echo "üßπ Cleaning up old containers and networks..."
          docker container prune -f
          docker network prune -f
          
          echo "üöÄ Starting containers with latest image..."
          docker compose up -d --force-recreate --renew-anon-volumes
          
          echo "‚è≥ Waiting for containers to initialize (60s)..."
          sleep 60
          
          echo "üîç Comprehensive container diagnostics..."
          echo "üìã All containers:"
          docker ps -a --format "table {{.Names}}\t{{.Status}}\t{{.Ports}}\t{{.Image}}"
          
          echo "üìã Running containers only:"
          docker ps --format "table {{.Names}}\t{{.Status}}\t{{.Ports}}"
          
          echo "üìã Docker networks:"
          docker network ls
          
          echo "üìã Compose project containers:"
          docker compose ps
          
          # Find actual container names dynamically
          WEB_CONTAINER=$(docker ps --filter "label=com.docker.compose.service=clyvanta-web" --format "{{.Names}}" | head -1)
          NGINX_CONTAINER=$(docker ps --filter "label=com.docker.compose.service=clyvanta-nginx" --format "{{.Names}}" | head -1)
          
          echo "üîç Detected containers:"
          echo "  Web container: ${WEB_CONTAINER:-NOT_FOUND}"
          echo "  Nginx container: ${NGINX_CONTAINER:-NOT_FOUND}"
          
          # Verify web container is responding (using dynamic name)
          echo "üåê Testing web container health..."
          if [ -n "$WEB_CONTAINER" ]; then
            for i in {1..10}; do
              echo "Attempt $i: Testing container $WEB_CONTAINER..."
              if docker exec "$WEB_CONTAINER" curl -f -s --max-time 5 http://localhost:3000 > /dev/null 2>&1; then
                echo "‚úÖ Web container health check passed on attempt $i"
                WEB_HEALTHY=true
                break
              else
                echo "‚è≥ Web container health check attempt $i/10 failed, retrying..."
                sleep 6
              fi
              
              if [ $i -eq 10 ]; then
                echo "‚ùå Web container health checks failed after 10 attempts"
                echo "üìã Container logs:"
                docker logs "$WEB_CONTAINER" --tail 30
                echo "üìã Container inspect:"
                docker inspect "$WEB_CONTAINER" --format '{{.State.Status}}: {{.State.Error}}'
              fi
            done
          else
            echo "‚ùå No web container found - checking external access..."
            WEB_HEALTHY=false
          fi
          
          # Alternative health check strategy - external access (more reliable)
          echo "üîó Testing external service access..."
          EXTERNAL_HEALTHY=false
          
          for i in {1..12}; do
            echo "External attempt $i: Testing service endpoints..."
            
            # Test port 80 (main nginx)
            if curl -f -s --max-time 10 http://localhost:80 > /dev/null 2>&1; then
              echo "‚úÖ Port 80 accessible on attempt $i"
              EXTERNAL_HEALTHY=true
              break
            fi
            
            # Test port 8080 (backup nginx)  
            if curl -f -s --max-time 10 http://localhost:8080 > /dev/null 2>&1; then
              echo "‚úÖ Port 8080 accessible on attempt $i"
              EXTERNAL_HEALTHY=true
              break
            fi
            
            # Test if web container is directly accessible (troubleshooting)
            if [ -n "$WEB_CONTAINER" ]; then
              WEB_IP=$(docker inspect "$WEB_CONTAINER" --format '{{range .NetworkSettings.Networks}}{{.IPAddress}}{{end}}' | head -1)
              if [ -n "$WEB_IP" ] && curl -f -s --max-time 5 "http://${WEB_IP}:3000" > /dev/null 2>&1; then
                echo "‚úÖ Web container directly accessible at $WEB_IP:3000 on attempt $i"
                echo "‚ö†Ô∏è But nginx proxy may have issues"
                EXTERNAL_HEALTHY=true
                break
              fi
            fi
            
            echo "‚è≥ External access attempt $i/12 failed, retrying..."
            sleep 8
          done
          
          # Final health assessment
          if [ "$WEB_HEALTHY" = "true" ] || [ "$EXTERNAL_HEALTHY" = "true" ]; then
            echo "‚úÖ Service is healthy (container or external access working)"
          else
            echo "‚ùå Service health checks failed completely"
            echo "üìã Final diagnostics:"
            docker ps -a
            if [ -n "$WEB_CONTAINER" ]; then
              echo "üìã Web container logs:"
              docker logs "$WEB_CONTAINER" --tail 50
            fi
            if [ -n "$NGINX_CONTAINER" ]; then
              echo "üìã Nginx container logs:"
              docker logs "$NGINX_CONTAINER" --tail 50
            fi
            echo "üìã System resources:"
            df -h
            free -h
            exit 1
          fi
          
          echo "üèÅ Deployment completed successfully!"
          echo "üìä Final container status:"
          docker ps --format "table {{.Names}}\t{{.Status}}\t{{.Ports}}"
        EOF
        
        # Cleanup SSH key
        rm -f ~/.ssh/deploy_key
        echo "‚úÖ SSH deployment completed"
        
    - name: Comprehensive Production Verification
      if: github.ref == 'refs/heads/main'
      run: |
        echo "üåç Comprehensive production deployment verification..."
        sleep 45
        
        # Progressive timeout strategy for server access
        echo "üì° Testing direct server access with progressive timeouts..."
        DIRECT_ACCESS=false
        
        # Quick test first (fast feedback)
        for timeout in 10 20 30; do
          echo "Testing with ${timeout}s timeout..."
          for port in 80 8080; do
            echo "  Trying port $port..."
            if curl -f -s --max-time $timeout "http://${{ secrets.DROPLET_IP }}:$port" > /dev/null 2>&1; then
              echo "‚úÖ Direct server port $port accessible (${timeout}s timeout)"
              DIRECT_ACCESS=true
              WORKING_PORT=$port
              break 2
            fi
          done
          sleep 5
        done
        
        # Content verification if server responds
        if [ "$DIRECT_ACCESS" = "true" ]; then
          echo "üìÑ Verifying content integrity..."
          CONTENT=$(curl -s --max-time 15 "http://${{ secrets.DROPLET_IP }}:$WORKING_PORT" | head -500)
          if echo "$CONTENT" | grep -q "Great Ideas Deserve Great Technology"; then
            echo "‚úÖ Content verification passed - latest code deployed"
            CONTENT_OK=true
          else
            echo "‚ö†Ô∏è Content verification failed - may be old deployment"
            echo "First 200 chars of response:"
            echo "$CONTENT" | head -c 200
            CONTENT_OK=false
          fi
        fi
        
        # Domain verification with enhanced error reporting
        echo "üåê Testing domain access via Cloudflare..."
        DOMAIN_ACCESS=false
        
        for i in {1..6}; do
          echo "Domain attempt $i/6..."
          RESPONSE=$(curl -s -w "HTTP_%{http_code}_TIME_%{time_total}s" --max-time 25 https://clyvanta.com -o /tmp/domain_response.html 2>&1)
          HTTP_CODE=$(echo "$RESPONSE" | grep -o 'HTTP_[0-9]*' | sed 's/HTTP_//')
          
          if [ "$HTTP_CODE" = "200" ]; then
            echo "‚úÖ Domain accessible (HTTP $HTTP_CODE) on attempt $i"
            
            # Verify domain content
            if grep -q "Great Ideas Deserve Great Technology" /tmp/domain_response.html 2>/dev/null; then
              echo "‚úÖ Domain content verification passed"
              DOMAIN_ACCESS=true
              break
            else
              echo "‚ö†Ô∏è Domain responds but content may be cached"
            fi
          elif [ "$HTTP_CODE" = "521" ]; then
            echo "‚ö†Ô∏è Cloudflare 521 error (Web server is down) on attempt $i"
          elif [ "$HTTP_CODE" = "522" ]; then
            echo "‚ö†Ô∏è Cloudflare 522 error (Connection timed out) on attempt $i"
          else
            echo "‚ö†Ô∏è Domain returned HTTP $HTTP_CODE on attempt $i"
          fi
          
          sleep 12
        done
        
        # Final assessment with detailed reporting
        echo "üìä Deployment Assessment:"
        echo "  Direct Server Access: ${DIRECT_ACCESS}"
        echo "  Content Verification: ${CONTENT_OK:-N/A}"
        echo "  Domain Access: ${DOMAIN_ACCESS}"
        echo "  Working Port: ${WORKING_PORT:-None}"
        
        # Determine success criteria
        if [ "$DIRECT_ACCESS" = "true" ] && [ "$CONTENT_OK" = "true" ]; then
          echo "‚úÖ DEPLOYMENT SUCCESSFUL: Server accessible with latest content"
          if [ "$DOMAIN_ACCESS" = "true" ]; then
            echo "‚úÖ BONUS: Domain also accessible immediately"
          else
            echo "‚ÑπÔ∏è Domain may take a few minutes to propagate through Cloudflare"
          fi
          exit 0
        elif [ "$DIRECT_ACCESS" = "true" ]; then
          echo "‚ö†Ô∏è PARTIAL SUCCESS: Server accessible but content verification issues"
          echo "‚ÑπÔ∏è This might be a caching issue or deployment race condition"
          exit 0
        else
          echo "‚ùå DEPLOYMENT FAILED: Server not accessible"
          echo "üîç Troubleshooting info:"
          echo "  - Check server containers manually via SSH"
          echo "  - Server IP: ${{ secrets.DROPLET_IP }}"
          echo "  - Tested ports: 80, 8080"
          exit 1
        fi