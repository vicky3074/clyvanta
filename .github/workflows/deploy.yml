name: üöÄ Git-Based Production Deployment

on:
  push:
    branches: [ main, staging ]

jobs:
  build-and-deploy:
    runs-on: ubuntu-latest
    environment: production
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
    
    - name: Deploy to Production
      if: github.ref == 'refs/heads/main'
      run: |
        echo "üöÄ Starting robust deployment to production..."
        
        # Setup SSH
        mkdir -p ~/.ssh
        echo "${{ secrets.SSH_PRIVATE_KEY }}" > ~/.ssh/deploy_key
        chmod 600 ~/.ssh/deploy_key
        ssh-keyscan -H ${{ secrets.DROPLET_IP }} >> ~/.ssh/known_hosts
        
        # Git-based deployment - build from source
        ssh -i ~/.ssh/deploy_key -o StrictHostKeyChecking=no ubuntu@${{ secrets.DROPLET_IP }} << 'EOF'
          echo "üì¶ Starting git-based deployment..."
          cd clyvanta-new || { echo "‚ùå Project directory not found"; exit 1; }
          
          echo "üìÑ Pulling latest code from GitHub..."
          git pull origin main || { echo "‚ùå Git pull failed"; exit 1; }
          
          echo "üìã Current system status:"
          docker ps --format "table {{.Names}}\t{{.Status}}\t{{.Ports}}"
          
          echo "üõë Gracefully stopping all containers..."
          docker compose down --timeout 30 || echo "‚ö†Ô∏è Some containers may already be stopped"
          
          echo "üßπ Cleaning up old containers and networks..."
          docker container prune -f
          docker network prune -f
          
          echo "üßπ Ensuring domain ports are available..."
          sudo fuser -k 80/tcp 443/tcp 8080/tcp 2>/dev/null || true
          sleep 5
          
          echo "üöÄ Building and starting containers from source..."
          docker compose up -d --build --force-recreate
          
          echo "‚è≥ Waiting for containers to initialize (60s)..."
          sleep 60
          
          echo "üîç Comprehensive container diagnostics..."
          echo "üìã All containers:"
          docker ps -a --format "table {{.Names}}\t{{.Status}}\t{{.Ports}}\t{{.Image}}"
          
          echo "üìã Running containers only:"
          docker ps --format "table {{.Names}}\t{{.Status}}\t{{.Ports}}"
          
          echo "üìã Docker networks:"
          docker network ls
          
          echo "üìã Compose project containers:"
          docker compose ps
          
          # Find the web and nginx containers  
          WEB_CONTAINER=$(docker ps --filter "label=com.docker.compose.service=clyvanta-web" --format "{{.Names}}" | head -1)
          NGINX_CONTAINER=$(docker ps --filter "label=com.docker.compose.service=clyvanta-nginx" --format "{{.Names}}" | head -1)
          
          echo "üîç Detected containers:"
          echo "  Web container: ${WEB_CONTAINER:-NOT_FOUND}"
          echo "  Nginx container: ${NGINX_CONTAINER:-NOT_FOUND}"
          
          # Verify containers are responding (multi-container setup)
          echo "üåê Testing multi-container health..."
          if [ -n "$WEB_CONTAINER" ] && [ -n "$NGINX_CONTAINER" ]; then
            for i in {1..10}; do
              echo "Attempt $i: Testing web container $WEB_CONTAINER..."
              if docker exec "$WEB_CONTAINER" curl -f -s --max-time 5 http://localhost:3000 > /dev/null 2>&1; then
                echo "‚úÖ Web container health check passed on attempt $i"
                CONTAINER_HEALTHY=true
                break
              else
                echo "‚è≥ Web container health check attempt $i/10 failed, retrying..."
                sleep 6
              fi
              
              if [ $i -eq 10 ]; then
                echo "‚ùå Web container health checks failed after 10 attempts"
                echo "üìã Web container logs:"
                docker logs "$WEB_CONTAINER" --tail 50
                echo "üìã Web container inspect:"
                docker inspect "$WEB_CONTAINER" --format '{{.State.Status}}: {{.State.Error}}'
              fi
            done
          else
            echo "‚ùå Multi-container setup not found - checking external access..."
            CONTAINER_HEALTHY=false
          fi
          
          # Alternative health check strategy - external access (more reliable)
          echo "üîó Testing external service access..."
          EXTERNAL_HEALTHY=false
          
          for i in {1..12}; do
            echo "External attempt $i: Testing service endpoints..."
            
            # Test port 80 (main nginx) - CRITICAL for domain mapping
            if curl -f -s --max-time 10 http://localhost:80 > /dev/null 2>&1; then
              echo "‚úÖ Port 80 accessible on attempt $i (DOMAIN MAPPING READY)"
              EXTERNAL_HEALTHY=true
              break
            fi
            
            # Test port 443 (SSL) - Required for HTTPS domain
            if curl -f -s -k --max-time 10 https://localhost:443 > /dev/null 2>&1; then
              echo "‚úÖ Port 443 SSL accessible on attempt $i (HTTPS DOMAIN READY)"
              EXTERNAL_HEALTHY=true
              break
            fi
            
            # Test port 8080 (backup nginx)  
            if curl -f -s --max-time 10 http://localhost:8080 > /dev/null 2>&1; then
              echo "‚úÖ Port 8080 accessible on attempt $i (BACKUP ACCESS)"
              EXTERNAL_HEALTHY=true
              break
            fi
            
            # Test if nginx container is directly accessible (troubleshooting)
            if [ -n "$NGINX_CONTAINER" ]; then
              NGINX_IP=$(docker inspect "$NGINX_CONTAINER" --format '{{range .NetworkSettings.Networks}}{{.IPAddress}}{{end}}' | head -1)
              if [ -n "$NGINX_IP" ] && curl -f -s --max-time 5 "http://${NGINX_IP}:80" > /dev/null 2>&1; then
                echo "‚úÖ Nginx container directly accessible at $NGINX_IP:80 on attempt $i"
                EXTERNAL_HEALTHY=true
                break
              fi
            fi
            
            echo "‚è≥ External access attempt $i/12 failed, retrying..."
            sleep 8
          done
          
          # Final health assessment
          if [ "$CONTAINER_HEALTHY" = "true" ] || [ "$EXTERNAL_HEALTHY" = "true" ]; then
            echo "‚úÖ Multi-container service is healthy (web + nginx working)"
          else
            echo "‚ùå Multi-container service health checks failed completely"
            echo "üìã Final diagnostics:"
            docker ps -a
            if [ -n "$WEB_CONTAINER" ]; then
              echo "üìã Web container logs:"
              docker logs "$WEB_CONTAINER" --tail 50
            fi
            if [ -n "$NGINX_CONTAINER" ]; then
              echo "üìã Nginx container logs:"
              docker logs "$NGINX_CONTAINER" --tail 50
            fi
            echo "üìã System resources:"
            df -h
            free -h
            exit 1
          fi
          
          echo "üèÅ Deployment completed successfully!"
          echo "üìä Final container status:"
          docker ps --format "table {{.Names}}\t{{.Status}}\t{{.Ports}}"
        EOF
        
        # Cleanup SSH key
        rm -f ~/.ssh/deploy_key
        echo "‚úÖ SSH deployment completed"
        
    - name: Comprehensive Production Verification
      if: github.ref == 'refs/heads/main'
      run: |
        echo "üåç Comprehensive production deployment verification..."
        sleep 45
        
        # Domain-focused verification strategy
        echo "üì° Testing domain mapping endpoints with progressive timeouts..."
        DIRECT_ACCESS=false
        
        # Test domain-critical ports first
        for timeout in 10 20 30; do
          echo "Testing with ${timeout}s timeout..."
          
          # Port 80 is CRITICAL for domain mapping (Cloudflare ‚Üí 80)
          echo "  Testing port 80 (DOMAIN CRITICAL)..."
          if curl -f -s --max-time $timeout "http://${{ secrets.DROPLET_IP }}:80" > /dev/null 2>&1; then
            echo "‚úÖ Port 80 accessible - DOMAIN MAPPING WORKING (${timeout}s)"
            DIRECT_ACCESS=true
            WORKING_PORT=80
            DOMAIN_READY=true
            break
          fi
          
          # Port 443 for HTTPS domain
          echo "  Testing port 443 (HTTPS DOMAIN)..."
          if curl -f -s -k --max-time $timeout "https://${{ secrets.DROPLET_IP }}:443" > /dev/null 2>&1; then
            echo "‚úÖ Port 443 SSL accessible - HTTPS DOMAIN WORKING (${timeout}s)"
            DIRECT_ACCESS=true
            WORKING_PORT=443
            DOMAIN_READY=true
            break
          fi
          
          # Port 8080 as fallback
          echo "  Testing port 8080 (FALLBACK)..."
          if curl -f -s --max-time $timeout "http://${{ secrets.DROPLET_IP }}:8080" > /dev/null 2>&1; then
            echo "‚úÖ Port 8080 accessible - BACKUP ACCESS (${timeout}s)"
            DIRECT_ACCESS=true
            WORKING_PORT=8080
            DOMAIN_READY=false
            break
          fi
          
          sleep 5
        done
        
        # Content verification if server responds
        if [ "$DIRECT_ACCESS" = "true" ]; then
          echo "üìÑ Verifying content integrity..."
          CONTENT=$(curl -s --max-time 15 "http://${{ secrets.DROPLET_IP }}:$WORKING_PORT" | head -500)
          if echo "$CONTENT" | grep -q "Great Ideas Deserve Great Technology"; then
            echo "‚úÖ Content verification passed - latest code deployed"
            CONTENT_OK=true
          else
            echo "‚ö†Ô∏è Content verification failed - may be old deployment"
            echo "First 200 chars of response:"
            echo "$CONTENT" | head -c 200
            CONTENT_OK=false
          fi
        fi
        
        # Domain verification with enhanced error reporting
        echo "üåê Testing domain access via Cloudflare..."
        DOMAIN_ACCESS=false
        
        for i in {1..6}; do
          echo "Domain attempt $i/6..."
          RESPONSE=$(curl -s -w "HTTP_%{http_code}_TIME_%{time_total}s" --max-time 25 https://clyvanta.com -o /tmp/domain_response.html 2>&1)
          HTTP_CODE=$(echo "$RESPONSE" | grep -o 'HTTP_[0-9]*' | sed 's/HTTP_//')
          
          if [ "$HTTP_CODE" = "200" ]; then
            echo "‚úÖ Domain accessible (HTTP $HTTP_CODE) on attempt $i"
            
            # Verify domain content
            if grep -q "Great Ideas Deserve Great Technology" /tmp/domain_response.html 2>/dev/null; then
              echo "‚úÖ Domain content verification passed"
              DOMAIN_ACCESS=true
              break
            else
              echo "‚ö†Ô∏è Domain responds but content may be cached"
            fi
          elif [ "$HTTP_CODE" = "521" ]; then
            echo "‚ö†Ô∏è Cloudflare 521 error (Web server is down) on attempt $i"
          elif [ "$HTTP_CODE" = "522" ]; then
            echo "‚ö†Ô∏è Cloudflare 522 error (Connection timed out) on attempt $i"
          else
            echo "‚ö†Ô∏è Domain returned HTTP $HTTP_CODE on attempt $i"
          fi
          
          sleep 12
        done
        
        # Final assessment with domain mapping focus
        echo "üìä Deployment Assessment:"
        echo "  Direct Server Access: ${DIRECT_ACCESS}"
        echo "  Content Verification: ${CONTENT_OK:-N/A}"
        echo "  Domain Mapping Ready: ${DOMAIN_READY:-false}"
        echo "  Domain Access: ${DOMAIN_ACCESS}"
        echo "  Working Port: ${WORKING_PORT:-None}"
        
        # Domain-focused success criteria
        if [ "$DIRECT_ACCESS" = "true" ] && [ "$CONTENT_OK" = "true" ] && [ "$DOMAIN_READY" = "true" ]; then
          echo "‚úÖ COMPLETE SUCCESS: Domain mapping working + latest content deployed"
          echo "üåç Port 80/443 accessible - clyvanta.com should work immediately"
          if [ "$DOMAIN_ACCESS" = "true" ]; then
            echo "‚úÖ VERIFIED: Domain also tested and working"
          else
            echo "‚ÑπÔ∏è Domain may take 1-2 minutes to propagate through Cloudflare"
          fi
          exit 0
        elif [ "$DIRECT_ACCESS" = "true" ] && [ "$CONTENT_OK" = "true" ]; then
          echo "‚ö†Ô∏è PARTIAL SUCCESS: Content deployed but domain mapping issues"
          echo "üîç Server accessible on port ${WORKING_PORT} but not domain-critical ports 80/443"
          echo "‚ÑπÔ∏è Production recovered but may need domain mapping investigation"
          exit 0
        elif [ "$DIRECT_ACCESS" = "true" ]; then
          echo "‚ö†Ô∏è MINIMAL SUCCESS: Server accessible but content/domain issues"
          echo "üîç Working port: ${WORKING_PORT}"
          echo "‚ÑπÔ∏è Production may be accessible but not latest deployment"
          exit 0
        else
          echo "‚ùå DEPLOYMENT FAILED: Server completely inaccessible"
          echo "üîç Troubleshooting info:"
          echo "  - Both container health AND domain mapping failed"
          echo "  - Server IP: ${{ secrets.DROPLET_IP }}"
          echo "  - Tested ports: 80 (domain), 443 (SSL), 8080 (backup)"
          echo "  - Check SSL certificate generation and port conflicts"
          exit 1
        fi